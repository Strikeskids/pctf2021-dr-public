use dr::charmap::{Charmap, Charset};
use dr::{cheese, consider, sundae, toppings, Re, EPS, NUL};
use sha3::{Digest, Sha3_256};
use std::collections::{HashMap, HashSet, VecDeque};
use std::fmt::{Display, Formatter, Write};
use std::rc::Rc;

#[derive(Debug)]
struct StateImpl {
    re: Rc<Re>,
    next: Charmap<State>,
    depth: usize,
    nullable: bool,
}

#[derive(Copy, Clone, Debug)]
struct State(usize);

impl State {
    const INITIAL: Self = State(0);
}

#[derive(Debug)]
pub struct Matcher {
    states: Vec<StateImpl>,
    res: HashMap<Rc<Re>, State>,
}

impl StateImpl {
    fn with_depth(re: Rc<Re>, depth: usize) -> Self {
        let nullable = re.nullable();
        StateImpl {
            re,
            next: Charmap::new(),
            nullable,
            depth,
        }
    }
}

trait CustomDisplay {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result;
}
impl<T: ?Sized + CustomDisplay> CustomDisplay for &T {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        CustomDisplay::fmt(&**self, f)
    }
}

struct CD<T>(T);

impl<T: CustomDisplay> Display for CD<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}
impl CustomDisplay for dr::charrange::CharRange {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let start = self.start();
        let end = std::char::from_u32(self.end() as u32 - 1).unwrap();
        if end > start {
            write!(f, "{}-{}", start, end)
        } else if start == '\0' {
            write!(f, "\\0")
        } else {
            write!(f, "{}", start)
        }
    }
}
impl CustomDisplay for dr::charmap::Charset {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        for cheese in self.ranges() {
            write!(f, "{}", CD(cheese))?
        }
        Ok(())
    }
}

impl CustomDisplay for Rc<Re> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        use Re::*;
        match &**self {
            Lit(s) => write!(f, "{}", s),
            Eps => write!(f, "ε"),
            Nul => write!(f, "∅"),
            Chars(cheese) => write!(f, "[{}]", CD(cheese)),
            Neg(s) => write!(f, "¬{}", CD(s)),
            And(ss) => {
                write!(f, "(")?;
                let mut first = true;
                for s in ss.iter() {
                    if !first {
                        write!(f, " & ")?;
                    }
                    first = false;
                    write!(f, "{}", CD(s))?;
                }
                write!(f, ")")
            }
            Alt(ss) => {
                write!(f, "(")?;
                let mut first = true;
                for s in ss.iter() {
                    if !first {
                        write!(f, " | ")?;
                    }
                    first = false;
                    write!(f, "{}", CD(s))?;
                }
                write!(f, ")")
            }
            Seq(a, b) => write!(f, "{} {}", CD(a), CD(b)),
            Star(a) => write!(f, "({})*", CD(a)),
            Moon(a, v, l) => write!(f, "moon({}, {}, {})", CD(a), v, l),
            Fan(a, c) => write!(f, "fan({}, {})", CD(a), c),
            Consider(ss, a, b, c) => {
                write!(f, "consider((")?;
                let mut first = true;
                for s in ss.iter() {
                    if !first {
                        write!(f, ", ")?;
                    }
                    first = false;
                    write!(f, "{}", CD(s))?;
                }
                write!(f, "), {}, {}, {})", a, b, c)
            }
        }
    }
}

impl Matcher {
    pub fn new(re: Rc<Re>) -> Self {
        Matcher {
            states: vec![StateImpl::with_depth(re.clone(), 0)],
            res: vec![(re, State::INITIAL)].into_iter().collect(),
        }
    }

    fn add_state(&mut self, re: Rc<Re>, depth: usize) -> State {
        if let Some(state) = self.res.get(&re) {
            return *state;
        } else {
            let imp = StateImpl::with_depth(re, depth);
            let state = State(self.states.len());
            self.res.insert(imp.re.clone(), state.clone());
            self.states.push(imp);
            state
        }
    }

    fn expand(&mut self, state: State) {
        let mut ch = '\0';
        while ch < std::char::MAX {
            self.step(state, &ch);
            ch = self.states[state.0].next.get_entry(&ch).unwrap().0.end()
        }
    }

    fn step(&mut self, state: State, ch: &char) -> State {
        let imp = &mut self.states[state.0];
        // println!("{:?} => {:?}", state, ch);
        if let Some(next) = imp.next.get(ch) {
            return *next;
        }
        let (cheese, next_re) = imp.re.derive(ch);
        let depth = imp.depth + 1;
        // println!("\t{} {}", CD(cheese.clone()), CD(next_re.clone()));

        let next = self.add_state(next_re.into(), depth);
        // println!("\t@ {:?}", next);
        let imp = &mut self.states[state.0];
        let inserted = imp.next.try_insert(cheese, next.clone());
        assert!(inserted);
        return next;
    }

    pub fn matches(&mut self, s: &str) -> bool {
        let mut state = State::INITIAL;
        for c in s.chars() {
            state = self.step(state, &c)
        }
        self.states[state.0].nullable
    }
}

struct StateInfo {
    path: String,
    loops: HashSet<(char, usize)>,
    prev: Option<(char, usize)>,
    alt_prev: HashSet<(char, usize)>,
    finished: bool,
}

impl StateImpl {
    fn transition_chars(&self, to: State) -> Charset {
        self.next
            .range_values()
            .filter_map(|(cheese, state)| if state.0 == to.0 { Some(cheese) } else { None })
            .cloned()
            .collect()
    }
}

#[derive(Debug)]
enum Path<T> {
    Edge(T),
    Seq(Vec<Path<T>>),
    Alt(Vec<Path<T>>),
}

fn path<'a>(infos: &Vec<StateInfo>, mut ptr: usize) -> Path<(usize, usize)> {
    let mut seq = VecDeque::new();
    loop {
        let info = &infos[ptr];
        if !info.alt_prev.is_empty() {
            let mut alts = Vec::new();
            if let Some((_, prev)) = info.prev {
                alts.push(Path::seq(vec![path(infos, prev), Path::Edge((prev, ptr))]));
            }
            for (_, prev) in info.alt_prev.iter() {
                let prev = *prev;
                alts.push(Path::seq(vec![path(infos, prev), Path::Edge((prev, ptr))]));
            }
            return Path::seq(std::iter::once(Path::Alt(alts)).chain(seq.into_iter()));
        }
        if let Some((_, prev)) = info.prev {
            seq.push_front(Path::Edge((prev, ptr)));
            ptr = prev;
        } else {
            break;
        }
    }
    Path::seq(seq.into_iter())
}

impl<T> Path<T> {
    fn map_inner<T2, F: FnMut(T) -> T2>(self, f: &mut F) -> Path<T2> {
        use Path::*;
        match self {
            Edge(t) => Edge(f(t)),
            Seq(ts) => Seq(ts.into_iter().map(|p| p.map_inner(f)).collect()),
            Alt(ts) => Alt(ts.into_iter().map(|p| p.map_inner(f)).collect()),
        }
    }

    fn map<T2, F: FnMut(T) -> T2>(self, mut f: F) -> Path<T2> {
        self.map_inner(&mut f)
    }
}

impl<T: PartialEq> Path<T> {
    fn tail(&self) -> Option<&T> {
        use Path::*;
        match self {
            Edge(e) => Some(e),
            Seq(ts) => ts.last().map(Self::tail).flatten(),
            Alt(ts) => ts
                .iter()
                .map(Self::tail)
                .reduce(|a, b| match (a, b) {
                    (Some(a), Some(b)) => {
                        if a == b {
                            Some(a)
                        } else {
                            None
                        }
                    }
                    _ => None,
                })
                .unwrap_or(None),
        }
    }

    fn into_tail(self) -> Option<(Self, T)> {
        use Path::*;
        match self {
            Edge(e) => Some((Seq(vec![]), e)),
            Seq(mut ts) => {
                if let Some(first) = ts.pop() {
                    match first.into_tail() {
                        Some((x, v)) => {
                            match x {
                                Seq(init) => ts.extend(init.into_iter()),
                                _ => ts.push(x),
                            };
                            Some((Seq(ts), v))
                        }
                        None => None,
                    }
                } else {
                    None
                }
            }
            Alt(ts) => {
                let mut all = Vec::new();
                let mut tail = None;
                for t in ts.into_iter() {
                    if let Some((rest, v)) = t.into_tail() {
                        match &tail {
                            Some(tail) => {
                                if tail != &v {
                                    return None;
                                }
                            }
                            None => tail = Some(v),
                        };
                        match rest {
                            Alt(ts) => all.extend(ts),
                            _ => all.push(rest),
                        }
                    } else {
                        return None;
                    }
                }
                match tail {
                    None => None,
                    Some(tail) => Some((Alt(all), tail)),
                }
        }
    }

    fn head(&self) -> Option<&T> {
        use Path::*;
        match self {
            Edge(e) => Some(e),
            Seq(ts) => ts.first().map(Self::head).flatten(),
            Alt(ts) => ts
                .iter()
                .map(Self::head)
                .reduce(|a, b| match (a, b) {
                    (Some(a), Some(b)) => {
                        if a == b {
                            Some(a)
                        } else {
                            None
                        }
                    }
                    _ => None,
                })
                .unwrap_or(None),
        }
    }

    fn into_head(self) -> Option<(T, Self)> {
        use Path::*;
        match self {
            Edge(e) => Some((e, Seq(vec![]))),
            Seq(ts) => {
                let mut iter = ts.into_iter();
                if let Some(first) = iter.next() {
                    match first.into_head() {
                        Some((v, x)) => {
                            let mut ts = Vec::new();
                            match x {
                                Seq(init) => ts.extend(init.into_iter()),
                                _ => ts.push(x),
                            };
                            ts.extend(iter);
                            Some((v, Seq(ts)))
                        }
                        None => None,
                    }
                } else {
                    None
                }
            }
            Alt(ts) => {
                let mut all = Vec::new();
                let mut head = None;
                for t in ts.into_iter() {
                    if let Some((v, rest)) = t.into_head() {
                        match &head {
                            Some(head) => {
                                if head != &v {
                                    return None;
                                }
                            }
                            None => head = Some(v),
                        };
                        match rest {
                            Alt(ts) => all.extend(ts),
                            _ => all.push(rest),
                        }
                    } else {
                        return None;
                    }
                }
                match head {
                    None => None,
                    Some(head) => Some((head, Alt(all))),
                }
        }
    }

    fn seq<I: IntoIterator<Item = Path<T>>>(ts: I) -> Self {
        let ts: Vec<_> = ts
            .into_iter()
            .flat_map(|t| match t {
                Path::Seq(ts) => ts,
                _ => vec![t],
            })
            .collect();
        match ts.len() {
            1 => ts.into_iter().next().unwrap(),
            _ => Path::Seq(ts),
        }
    }

    fn simplify(self) -> Self {
        use Path::*;
        match self {
            Edge(_) => self,
            Seq(ts) => Self::seq(ts.into_iter().map(Self::simplify)),
            mut t @ Alt(_) => {
                let mut heads = Vec::new();
                while t.head().is_some() {
                    let (head, rest) = t.into_head().unwrap();
                    heads.push(Edge(head));
                    t = rest;
                }
                let mut tails = Vec::new();
                while t.tail().is_some() {
                    let (rest, tail) = t.into_tail().unwrap();
                    tails.push(Edge(tail));
                    t = rest;
                }
                Self::seq(
                    heads
                        .into_iter()
                        .chain(std::iter::once(t))
                        .chain(tails.into_iter().rev()),
                )
            } 
        }
    }
}

impl<T: Clone> Path<T> {
    fn all(&self) -> Vec<Vec<T>> {
        use Path::*;
        match self {
            Edge(e) => vec![vec![e.clone()]],
            Alt(ts) => ts.iter().flat_map(Self::all).collect(),
            Seq(ts) => {
                let mut prev = vec![vec![]];
                for t in ts.iter() {
                    let mut next = Vec::new();
                    for v in t.all() {
                        for p in prev.iter() {
                            next.push(p.iter().chain(v.iter()).cloned().collect());
                        }
                    }
                    prev = next;
                }
                prev
            } 
        }
    }
}

impl std::fmt::Display for Path<Charset> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        use Path::*;
        match self {
            Edge(cs) => {
                if cs.len() == 1 {
                    let mut iter = cs.ranges();
                    let range = iter.next().unwrap();
                    let value = range.start();
                    assert!(
                        (range.end() as u32 - range.start() as u32) == 1u32
                            && iter.next().is_none()
                    );
                    write!(f, "{}", value)
                } else {
                    write!(f, "[{}]", CD(cs))
                }
            }
            Seq(paths) => {
                for p in paths.iter() {
                    write!(f, "{}", p)?
                }
                Ok(())
            }
            Alt(paths) => {
                write!(f, "(")?;
                let mut first = true;
                for p in paths {
                    if !first {
                        write!(f, "|")?;
                    } else {
                        first = false;
                    }
                    write!(f, "{}", p)?;
                }
                write!(f, ")")
            }
        }
    }
}

#[allow(dead_code)]
fn compute_mod(hex: &str, modulus: u32) -> u32 {
    let mut value = 0;
    for c in hex.chars() {
        value = value * 16 % modulus;
        match c {
            '0'..='9' => {
                value = (value + c as u32 - '0' as u32) % modulus;
            }
            'a'..='f' => {
                value = (value + c as u32 - 'a' as u32 + 10) % modulus;
            }
            _ => panic!("invalid hex char {}", c),
        }
    }
    value
}

#[allow(dead_code)]
fn check_expand(m: &mut Matcher) {
    let mut state = State::INITIAL;
    for c in "1000".chars() {
        state = m.step(state, &c);
    }
    m.expand(state);
    for (rng, next) in m.states[state.0].next.range_values() {
        println!("{} {:?}\n\t{}", CD(rng), next, CD(&m.states[next.0].re));
    }
    println!("{}", CD(m.states[state.0].transition_chars(State(6))));
}

fn make_re() -> Re {
    NUL.neg()
        & (NUL.neg()
            * consider(
                vec![toppings("cdb"), sundae("cdb") * toppings("db").star().neg()],
                2,
                3,
            ))
        & (NUL.neg() * cheese('1'..='3').sun() * cheese('3'..='7').sun() * NUL.neg())
        & consider(
            vec![
                toppings("05a"),
                toppings("16b"),
                toppings("27cf"),
                toppings("38dx"),
                toppings("49e"),
            ],
            0,
            7,
        )
        & consider(
            vec![toppings("d3ad"), toppings("c0412"), cheese('5'..='9'), toppings("beef")],
            3,
            5,
        )
        & (cheese('0'..='9').moon_phase(1, 3) * cheese('a'..='f').moon_phase(2, 3))
            .moon_phase(0, 2)
        & (sundae("10") * EPS.neg()).moon_phase(0, 3)
        & (NUL.neg() * (sundae("af") | sundae("73") | cheese('0'..='9') * sundae("a") | sundae("ccc") | cheese('0'..='9').fan(7)) * NUL.neg()).neg()
        & (NUL.neg() * (cheese('a'..='f') * NUL.neg()).fan(6)).neg()
        // & (consider(
        //     std::iter::successors(Some('0'), |x| match x {
        //         '0'..='8' | 'a'..='e' => std::char::from_u32(*x as u32 + 1),
        //         '9' => Some('a'),
        //         _ => None,
        //     })
        //     .map(cheese)
        //     .collect::<Vec<_>>(),
        //     31337,
        //     7777,
        // ))
        & NUL.neg()
}

#[test]
fn run_check_expand() {
    let re = Rc::from(make_re());
    check_expand(&mut Matcher::new(re.clone()));
}

fn expand_fully<I: Into<Rc<Re>>>(re: I) -> (Matcher, Vec<StateInfo>) {
    let mut m = Matcher::new(re.into());
    let mut index = 0;
    let mut remaining = VecDeque::new();
    let mut infos = vec![StateInfo {
        path: String::from(""),
        loops: HashSet::new(),
        alt_prev: HashSet::new(),
        prev: None,
        finished: false,
    }];
    loop {
        let (target, ch) = if index < infos.len() {
            (index, '\0')
        } else if let Some(x) = remaining.pop_back() {
            x
        } else {
            break;
        };
        if ch == std::char::MAX {
            infos[target].finished = true;
            continue;
        }
        index = usize::max(target + 1, index);
        let State(next) = m.step(State(target), &ch);
        if next >= infos.len() {
            let mut s = String::from(&infos[target].path);
            s.push(ch);
            infos.push(StateInfo {
                path: s,
                loops: HashSet::new(),
                alt_prev: HashSet::new(),
                prev: Some((ch, target)),
                finished: false,
            });
        } else {
            if !infos[next].finished {
                infos[next].loops.insert((ch, target));
            } else {
                infos[next].alt_prev.insert((ch, target));
            }
        }
        assert!(infos.len() == m.states.len());
        let imp = &m.states[target];
        let ch = imp.next.last_key().unwrap().end();
        remaining.push_back((target, ch))
    }
    (m, infos)
}

fn all_results(m: &Matcher, infos: &Vec<StateInfo>) -> HashMap<u32, Vec<(String, u32)>> {
    let mods = [31337, 313337, 133337, 73331];
    let mut values = HashMap::new();
    for i in 0..m.states.len() {
        if m.states[i].nullable {
            let p = path(&infos, i)
                .map(|(from, to)| m.states[from].transition_chars(State(to)))
                .simplify();
            for p in p.all().into_iter() {
                let mut s = String::new();
                for x in p {
                    write!(&mut s, "{}", CD(x)).unwrap();
                }
                for m in mods.iter() {
                    values
                        .entry(compute_mod(&s, *m))
                        .or_insert(Vec::new())
                        .push((s.clone(), *m))
                }
            }
        }
    }
    values
}

fn construct() {
    let (m, infos) = expand_fully(make_re());
    println!("Done expanding");
    let mut values: Vec<_> = all_results(&m, &infos).into_iter().collect();
    values.sort();
    for (k, v) in values.iter() {
        println!("{:7} {} {} {}", k, v.len(), v[0].1, v[0].0)
    }
    println!("total states = {}", m.states.len());
}

fn solve() {
    let (m, infos) = expand_fully(make_re());
    let values = all_results(&m, &infos);
    println!("{:?}", values[&7777]);
}

const CARD: &str = "10174cdbf10810c";
const FLAG: &str = "a_pr1m3_a_day_k33ps_th3_D0ctor_Firmly_Away";

#[test]
fn check_answers() {
    let mut m = Matcher::new(make_re().into());
    assert!(m.matches("10510cdbe93610c"));
    assert!(m.matches(CARD));
}

fn gen_flag() {
    let mut hasher = Sha3_256::new();
    hasher.update(CARD.as_bytes());
    let hash = hasher.finalize();
    let mut bytes = Vec::new();
    for (a, b) in hash.iter().cycle().zip(FLAG.bytes()) {
        bytes.push(a ^ b);
    }
    println!("{:?}", bytes)
}

fn main() {
    match std::env::args().nth(1) {
        Some(ref s) if s == "solve" => solve(),
        Some(ref s) if s == "gen-flag" => gen_flag(),
        _ => construct(),
    }
}
